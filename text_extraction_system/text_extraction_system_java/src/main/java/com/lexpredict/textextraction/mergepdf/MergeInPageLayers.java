package com.lexpredict.textextraction.mergepdf;

import org.apache.commons.cli.*;
import org.apache.pdfbox.multipdf.LayerUtility;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject;

import java.awt.geom.AffineTransform;
import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Merges specified PDF pages into the original PDF as layers in front of the original page content.
 * May be used to put the results of the pages OCR by Tesseract in front of the pages keeping the original PDF
 * structure and annotations and small PDF size.
 *
 * Workflow:
 * 1. Figure out if a PDF page requires OCR or not. If yes, then:
 * 2. Generate an image of a PDF page with the existing text elements removed and only the image elements left.
 *    See GetOCRImages class.
 * 3. Execute Tesseract on the page image specifying it to return the text-only PDF with the transparent
 * glyph-less text and no image background.
 * 4. Merge the transparent glyph-less text into the original PDF putting it in front of the page data
 * using this class.
 *
 * The original bookmarks and the structure of the PDF is kept, the original text elements are left untouched
 * and in front of the original image elements there will be the glyph-less text layer generated by OCR.
 *
 */
public class MergeInPageLayers {

    private static final String EXT_PDF = ".pdf";

    private static Pattern PAGE_NUM_FN = Pattern.compile("(\\d+)=(.*)");

    public static void main(String[] args) throws IOException {

        CommandLine cmd = parseCliArgs(args);

        String pdf = cmd.getOptionValue("original-pdf");
        String pagesDirStr = cmd.getOptionValue("page-dir", null);
        String password = cmd.getOptionValue("password");
        String dstPdf = cmd.getOptionValue("dst-pdf");


        Map<Integer, File> pageToFn = new HashMap<>();

        if (pagesDirStr != null) {
            File pagesDir = new File(pagesDirStr);
            File[] pageFiles = pagesDir.listFiles(new FileFilter() {
                @Override
                public boolean accept(File pathname) {
                    return pathname.getName().endsWith(EXT_PDF);
                }
            });

            if (pageFiles == null) {
                System.out.println("Page directory is invalid:\n" + pagesDirStr);
                return;
            }

            for (File fn : pageFiles) {
                String[] nameExt = fn.getName().split("\\.");
                try {
                    int page = Integer.parseInt(nameExt[0]);
                    pageToFn.put(page, fn);
                } catch (NumberFormatException nfe) {
                    //continue
                }
            }

            if (pageToFn.isEmpty()) {
                System.out.println("Page directory does not contain page files named [int_page_num].pdf\n" + pagesDirStr);
            }
        }

        for (String arg : cmd.getArgList()) {
            Matcher m = PAGE_NUM_FN.matcher(arg);
            if (m.find()) {
                int pageNum = Integer.parseInt(m.group(1));
                String pageFn = m.group(2);
                pageToFn.put(pageNum, new File(pageFn));
            }

        }

        try (PDDocument origDocument = PDDocument.load(new File(pdf), password)) {
            LayerUtility layerUtility = new LayerUtility(origDocument);
            for (Map.Entry<Integer, File> pageFn : pageToFn.entrySet()) {
                int pageNumZeroBased = pageFn.getKey() - 1;
                try (PDDocument mergePageDocument = PDDocument.load(pageFn.getValue(), (String) null)) {
                    PDFormXObject textPageForm = layerUtility.importPageAsForm(mergePageDocument, 0);
                    PDPage dstPage = origDocument.getPage(pageNumZeroBased);
                    layerUtility.wrapInSaveRestore(dstPage);

                    PDRectangle destBox = dstPage.getBBox();
                    PDRectangle sourceBox = textPageForm.getBBox();
                    double scaleX = destBox.getWidth() / sourceBox.getWidth();
                    double scaleY = destBox.getHeight() / sourceBox.getHeight();
                    AffineTransform affineTransform = new AffineTransform();
                    affineTransform.scale(scaleX, scaleY);
                    layerUtility.appendFormAsLayer(dstPage, textPageForm, affineTransform,
                            "Recognized Text for Page " + pageFn.getKey());
                }
            }
            origDocument.save(dstPdf);
        }
    }


    protected static CommandLine parseCliArgs(String[] args) {
        Options options = new Options();

        Option pwrd = new Option("p", "password", true,
                "PDF file password.");
        pwrd.setRequired(false);
        options.addOption(pwrd);

        Option originalPDF = new Option("orig", "original-pdf", true,
                "Original PDF file to merge page layers.");
        originalPDF.setRequired(true);
        options.addOption(originalPDF);

        Option pageDir = new Option("pages", "page-dir", true,
                "Directory containing page PDF files named as [page_num_1_based].pdf");
        pageDir.setRequired(false);
        options.addOption(pageDir);

        Option dstPDF = new Option("dst", "dst-pdf", true,
                "File name to save the resulting PDF.");
        dstPDF.setRequired(true);
        options.addOption(dstPDF);

        CommandLineParser parser = new DefaultParser();
        HelpFormatter formatter = new HelpFormatter();
        try {
            return parser.parse(options, args);
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            formatter.printHelp(MergeInPageLayers.class.getName(), options);
            System.exit(1);
        }
        return null;
    }

}
